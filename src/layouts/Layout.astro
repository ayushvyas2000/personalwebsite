---
import '../styles/global.css';
import { siteConfig } from '../data/portfolio';

interface Props {
  title?: string;
  description?: string;
}

const { 
  title = siteConfig.title, 
  description = siteConfig.description 
} = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- Primary Meta Tags -->
    <title>{title}</title>
    <meta name="title" content={title} />
    <meta name="description" content={description} />
    <meta name="author" content={siteConfig.author} />
    <meta name="keywords" content={siteConfig.keywords.join(', ')} />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content={siteConfig.siteUrl} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={`${siteConfig.siteUrl}${siteConfig.ogImage}`} />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={siteConfig.siteUrl} />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="twitter:image" content={`${siteConfig.siteUrl}${siteConfig.ogImage}`} />
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link 
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" 
      rel="stylesheet" 
    />
    
    <!-- Canonical URL -->
    <link rel="canonical" href={siteConfig.siteUrl} />
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#0a0a0f" />
  </head>
  <body class="bg-dark min-h-screen antialiased noise-overlay">
    <!-- Scroll Progress Bar -->
    <div class="scroll-progress" id="scroll-progress"></div>
    
    <!-- Scan Line Effect -->
    <div class="scanline"></div>

    <!-- Dynamic background orbs that follow scroll -->
    <div class="fixed inset-0 pointer-events-none overflow-hidden z-0" id="dynamic-bg">
      <div class="bg-orb bg-orb-1" id="bg-orb-1" style="top: 20%; left: 10%;"></div>
      <div class="bg-orb bg-orb-2" id="bg-orb-2" style="top: 60%; right: 10%;"></div>
      <div class="bg-orb bg-orb-3" id="bg-orb-3" style="top: 40%; left: 50%;"></div>
    </div>

    <div class="relative z-10">
      <slot />
    </div>
    
    <!-- ==========================================
         MASTER SCROLL & ANIMATION ENGINE
         ========================================== -->
    <script>
      // ==========================================
      // SCROLL PROGRESS BAR
      // ==========================================
      const progressBar = document.getElementById('scroll-progress');
      
      function updateScrollProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;
        if (progressBar) {
          progressBar.style.transform = `scaleX(${scrollPercent})`;
        }
      }

      // ==========================================
      // NAVBAR SCROLL EFFECT
      // ==========================================
      const navbar = document.getElementById('main-navbar');
      
      function updateNavbar() {
        if (navbar) {
          if (window.scrollY > 50) {
            navbar.classList.add('navbar-scrolled');
          } else {
            navbar.classList.remove('navbar-scrolled');
          }
        }
      }

      // ==========================================
      // DYNAMIC BACKGROUND ORBS ON SCROLL
      // ==========================================
      const orb1 = document.getElementById('bg-orb-1');
      const orb2 = document.getElementById('bg-orb-2');
      const orb3 = document.getElementById('bg-orb-3');

      function updateBackgroundOrbs() {
        const scrollY = window.scrollY;
        const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
        const progress = maxScroll > 0 ? scrollY / maxScroll : 0;

        if (orb1) {
          orb1.style.transform = `translate(${Math.sin(progress * Math.PI * 2) * 100}px, ${scrollY * -0.1}px)`;
        }
        if (orb2) {
          orb2.style.transform = `translate(${Math.cos(progress * Math.PI * 3) * 80}px, ${scrollY * 0.05}px)`;
        }
        if (orb3) {
          orb3.style.transform = `translate(${Math.sin(progress * Math.PI * 4) * 60}px, ${scrollY * -0.08}px)`;
        }
      }

      // ==========================================
      // ADVANCED INTERSECTION OBSERVER
      // Multiple animation types based on data-animate value
      // ==========================================
      const animationMap: Record<string, string> = {
        '': 'animate-fade-in-up',
        'fade-up': 'animate-fade-in-up',
        'rotate-left': 'animate-rotate-in-left',
        'rotate-right': 'animate-rotate-in-right',
        'scale-3d': 'animate-scale-in-3d',
        'flip-x': 'animate-flip-in-x',
        'slide-blur': 'animate-slide-up-blur',
      };

      const observerOptions = {
        root: null,
        rootMargin: '0px 0px -50px 0px',
        threshold: 0.1
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const el = entry.target as HTMLElement;
            const animType = el.getAttribute('data-animate') || '';
            const animClass = animationMap[animType] || 'animate-fade-in-up';
            
            el.classList.add(animClass);
            el.style.opacity = '1';

            // Handle reveal lines
            const revealLine = el.querySelector('.reveal-line');
            if (revealLine) {
              revealLine.classList.add('visible');
            }

            // Handle timeline lines
            const timelineLine = el.querySelector('.timeline-line');
            if (timelineLine) {
              timelineLine.classList.add('visible');
            }
          }
        });
      }, observerOptions);

      // ==========================================
      // PARALLAX EFFECT FOR SECTIONS
      // ==========================================
      const parallaxElements = document.querySelectorAll('[data-parallax]');
      
      function updateParallax() {
        parallaxElements.forEach((el) => {
          const htmlEl = el as HTMLElement;
          const speed = parseFloat(htmlEl.getAttribute('data-parallax') || '0.1');
          const rect = htmlEl.getBoundingClientRect();
          const centerY = rect.top + rect.height / 2;
          const viewportCenter = window.innerHeight / 2;
          const offset = (centerY - viewportCenter) * speed;
          htmlEl.style.transform = `translateY(${offset}px)`;
        });
      }

      // ==========================================
      // 3D CARD TILT ON HOVER
      // ==========================================
      function init3DCards() {
        const cards = document.querySelectorAll('.card-3d-hover');
        cards.forEach(card => {
          const el = card as HTMLElement;
          
          el.addEventListener('mousemove', (e: MouseEvent) => {
            const rect = el.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const rotateX = ((y - centerY) / centerY) * -8;
            const rotateY = ((x - centerX) / centerX) * 8;
            
            el.style.transform = `perspective(800px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(10px)`;
          });

          el.addEventListener('mouseleave', () => {
            el.style.transform = 'perspective(800px) rotateX(0deg) rotateY(0deg) translateZ(0px)';
          });
        });
      }

      // ==========================================
      // MAGNETIC HOVER EFFECT
      // ==========================================
      function initMagneticElements() {
        const magneticEls = document.querySelectorAll('.magnetic');
        magneticEls.forEach(el => {
          const htmlEl = el as HTMLElement;
          
          htmlEl.addEventListener('mousemove', (e: MouseEvent) => {
            const rect = htmlEl.getBoundingClientRect();
            const x = e.clientX - rect.left - rect.width / 2;
            const y = e.clientY - rect.top - rect.height / 2;
            htmlEl.style.transform = `translate(${x * 0.2}px, ${y * 0.2}px)`;
          });

          htmlEl.addEventListener('mouseleave', () => {
            htmlEl.style.transform = 'translate(0px, 0px)';
          });
        });
      }

      // ==========================================
      // COUNTER ANIMATION FOR STATS
      // ==========================================
      function initCounters() {
        const counters = document.querySelectorAll('[data-count]');
        const counterObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const el = entry.target as HTMLElement;
              const target = parseInt(el.getAttribute('data-count') || '0', 10);
              let current = 0;
              const increment = target / 40;
              const timer = setInterval(() => {
                current += increment;
                if (current >= target) {
                  el.textContent = target.toString();
                  clearInterval(timer);
                } else {
                  el.textContent = Math.floor(current).toString();
                }
              }, 30);
              counterObserver.unobserve(el);
            }
          });
        }, { threshold: 0.5 });

        counters.forEach(el => counterObserver.observe(el));
      }

      // ==========================================
      // MASTER SCROLL HANDLER (throttled via rAF)
      // ==========================================
      let ticking = false;

      function onScroll() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateScrollProgress();
            updateNavbar();
            updateBackgroundOrbs();
            updateParallax();
            ticking = false;
          });
          ticking = true;
        }
      }

      // ==========================================
      // INITIALIZATION
      // ==========================================
      document.addEventListener('DOMContentLoaded', () => {
        // Set up scroll-triggered animations
        const animatedElements = document.querySelectorAll('[data-animate]');
        animatedElements.forEach(el => {
          (el as HTMLElement).style.opacity = '0';
          observer.observe(el);
        });

        // Initialize interactive effects
        init3DCards();
        initMagneticElements();
        initCounters();

        // Initial state
        updateScrollProgress();
        updateNavbar();
      });

      // Attach scroll handler
      window.addEventListener('scroll', onScroll, { passive: true });

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        document.documentElement.style.setProperty('--animation-duration', '0.01s');
        const scanline = document.querySelector('.scanline') as HTMLElement;
        if (scanline) scanline.style.display = 'none';
      }
    </script>
  </body>
</html>
